---
title: "network analysis"
author: "Gabriella Spiegler"
date: "feb 18"
output:
  html_document: default
  pdf_document: default
---

11-02 shared last
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(tidyverse)
library(janitor)
library(readr)

library(bootnet)
library(qgraph)
library(mgm)

library(naniar)

library(igraph)
library(NetworkComparisonTest)

library(summarytools)
library(huge)

```


# == PART 1:  Depression and anxiety network ==
```{r}
data_og <- read_csv("Dataset; 38.csv")
# == Node selection ==
dep <- data_og %>% dplyr::select(MS_Mood_Depressed,
                          MS_AnhedoniaYN,
                          MS_AppetiteYN,
                          MS_SleepYN,
                          MS_Psychomotor,
                          MS_LowEnergy,
                          MS_Guilt,
                          MS_Concentration,
                          MS_SuicideIntent,
                          
                          GAD_Restless,
                          GAD_ExcessWorry,
                          GAD_LackControl)

dep %>% summary()
dep$MS_Mood_Depressed %>% tabyl()



#dfSummary(dep) %>% view()



# == Look at missing ==
dep %>% naniar::mcar_test() # p value is 0..

dep$MS_Mood_Depressed %>%  tabyl() %>% adorn_pct_formatting()
dep$MS_AnhedoniaYN %>% tabyl() %>% adorn_pct_formatting()
dep$MS_AppetiteYN %>% tabyl() %>% adorn_pct_formatting()
dep$MS_Concentration %>% tabyl() %>% adorn_pct_formatting()  
dep$MS_SleepYN %>% tabyl() %>% adorn_pct_formatting()
dep$MS_Psychomotor %>% tabyl() %>% adorn_pct_formatting()
dep$MS_LowEnergy %>% tabyl() %>% adorn_pct_formatting()
dep$MS_Guilt %>% tabyl() %>% adorn_pct_formatting()
dep$MS_SuicideIntent %>% tabyl() %>% adorn_pct_formatting()

# == Omit missing ==
# recode the MS_Mood_Depressed #10:15
depc <- replace_with_na(dep, replace = list(MS_Mood_Depressed = -999))
depc <- depc %>% na.omit() 
depc %>% dim() #674 12


summary(is.na(depc))
##datagad[complete.cases(datagad),] #721
#data %>% 

depc$MS_Mood_Depressed %>% tabyl()

```


**No perfect multicollinearity**
variables are not perfectly correlated
```{r, eval = F}

cor_matrixd <- cor(depc) # look for correlationbsn close to 1 or -1
cor_matrixd

```
GAD ones are highly correlated 
```{r}
depc %>% summary
```

```{r}
depc %>% dim()
```


# Matrix, Specify type and levels
```{r}
dat_dep<- list("data" = NULL, 
                  "type" = NULL, 
                  "level" = NULL,
                  "names" = NULL,
                  "labels" = NULL,
                  "grouplabels"= NULL)


# Fill in
dat_dep$data <- as.matrix(subset(depc, select = c(MS_Mood_Depressed,
                          MS_AnhedoniaYN,
                          MS_AppetiteYN,
                          MS_SleepYN,
                          MS_Psychomotor,
                          MS_LowEnergy,
                          MS_Guilt,
                          MS_Concentration,
                          MS_SuicideIntent,
                          
                          GAD_Restless,
                          GAD_ExcessWorry,
                          GAD_LackControl))) 


dat_dep$type <- c(rep("c",12)) # c categorical; g continuous

dat_dep$level <- c(rep(2,12)) # 1 for Continuous variables by convention; >1 for categorical



dat_dep$labels <- c('MS_Mood_Depressed',
                          'MS_AnhedoniaYN',
                          'MS_AppetiteYN',
                          'MS_SleepYN',
                          'MS_Psychomotor',
                          'MS_LowEnergy',
                          'MS_Guilt',
                          'MS_Concentration',
                          'MS_SuicideIntent',
                          
                          'GAD_Restless',
                          'GAD_ExcessWorry',
                          'GAD_LackControl')

dat_dep$names <- c('DepressedMood',
                          'Anhedonia',
                          'Appetite',
                          'Sleep',
                          'Psychomotor',
                          'LowEnergy',
                          'Guilt',
                          'Concentration',
                          'SuicideIntent',
                          'GAD_Restless',
                          'GAD_ExcessWorry',
                          'GAD_LackControl')


#dat_dep$grouplabels <- list(c("MS" = dat_dep$labels[1:9],"GAD" = dat_dep$labels[10:12]))


```

# 1) Estimate Dep Network 
```{r}
# == Fit Network ==
network_dep <- estimateNetwork(data = dat_dep$data,  default="IsingFit")

## set up network input
Labels1dep <- c('Dep', 'Anh', 'App', 'Sle', 'Mot','Ene',
               'Gui', 'Con','Sui','Res','Wor','LCo')

Names1dep <- c('DepressedMood',
                          'Anhedonia',
                          'Appetite',
                          'Sleep',
                          'Psychomotor',
                          'LowEnergy',
                          'Guilt',
                          'Concentration',
                          'SuicideIntent',
                          'GAD_Restless',
                          'GAD_ExcessWorry',
                          'GAD_LackControl')

GroupLabels1dep <- list("MDD" = c(1:9), "GAD" = c(10:12)) 




  ##n1_gad %>% plot()
edges_dep <- getWmat(network_dep)
```

# visualize (simple) network and edge heatmap
```{r}
# ==== RESULTS for Dep network ====

# visualize network -- simpler ver
qgraph(network_dep$graph, 
       #result_gad$graph, 
       layout = "spring",
       cut = 0,
       palette = 'colorblind',
       labels = Labels1dep,
       nodeNames = Names1dep       )



# == Edge weights and centrality==
##result_dep$graph

# edge weights
edgesn2 <- network_dep %>% getWmat()
edgesn2


# edge heat map
library(ggcorrplot)
ggcorrplot(network_dep$graph, method="circle", legend = "Edge Weights", 
           lab=TRUE, lab_size=2, type = "lower", color= c("red", "white", "blue"),
           show.diag = TRUE, tl.srt = 70, title = "Network 2 - GAD-MDD symptoms")
```


# ~ NEW:  edge weighs ordered
```{r}
# NEW -- edges values
heat_dep <- ggcorrplot(network_dep$graph, method="circle", legend = "Edge Weights", 
           lab=TRUE, lab_size=2, type = "lower", color= c("red", "white", "blue"),
           show.diag = TRUE, tl.srt = 70, title = "Network 2 - GAD-MDD symptoms")

heat_dep$data %>% arrange(desc(value)) # NEW ... arrange by greatest edge values

```

```{r}
# these two are the same
##getWmat(network_dep)
##network_dep$graph


##network_dep$results what is this
```



# ~ What are the most central nodes for Dep
## centrality values ordered
- based on strength: restless, excess worry
```{r 11-28}
# == Centrality table and plot ==

centralityPlot(edgesn2, include = c('Strength', 'ExpectedInfluence'))


# NEW - centrality plot values
cplot_dep <- centralityPlot(edgesn2, include = c('Strength', 'ExpectedInfluence'))



cplot_dep$data %>%   # NEW ... arrange by greatest centrality
  
  filter(measure == "ExpectedInfluence") %>%
  arrange(desc(value)) #strength and EI are the same values


# ~ centrality values ordered
#from the centralityPlot output
#plott$data %>% summary()
#plott$data %>% filter(measure == 'ExpectedInfluence') %>% arrange(desc(value))

```

```{r, eval = F}
# contains standardized centrality estimate
#centralityTable(edgesn2) %>% filter(measure == c("Strength")) %>% knitr::kable()

#are the central nodes SIGNIFICANTLY more central though? ==> centrality difference test

```


#  ~ redo network plot
```{r edits 11-28}
library(qgraph)


#obtain a weights matrix
netdep_edges <- getWmat(network_dep)
netdep_edges #none of them are negative anyway
```


```{r edits 11-28}
# rename nodes and labels
Names1dep.2 <- c('Depressed mood', 'Anhedonia',
             'Appetite prob', 'Sleep prob',
             'Psychomotor retardation', 'Low energy',
             'Guilt', 'Concentration problems',
             'Suicide intentions',
             'Restlessness',
             'Excessive worry', 'Lack of control')
```


#~~ NEW: batch3 heat map for Pain day poster
Jan 18 2024 update
```{r, eval = F}
#didnt work
network_dep3 <- network_dep

network_dep3$data$MS_Mood_Depressed <- network_dep3$data$Dep
network_dep3$data$MS_AnhedoniaYN<- network_dep3$data$Anh
network_dep3$data$MS_AppetiteYN<- network_dep3$data$App
network_dep3$data$MS_SleepYN<- network_dep3$data$Sle
network_dep3$data$MS_Psychomotor<- network_dep3$data$Mot
network_dep3$data$MS_LowEnergy<- network_dep3$data$Ene
network_dep3$data$MS_Guilt<- network_dep3$data$Gui
network_dep3$data$MS_Concentration<- network_dep3$data$Con
network_dep3$data$MS_SuicideIntent <- network_dep3$data$Sui

network_dep3$data$GAD_Restless <- network_dep3$data$Res
network_dep3$data$GAD_ExcessWorry <- network_dep3$data$Wor
network_dep3$data$GAD_LackControl <- network_dep3$data$LCo
```


```{r}
heatmapjan <- ggcorrplot(network_dep$graph,  #corr matrix to visualize
           method="circle",
           type = "lower", 
           
           legend = "Edge Weights", 
           
           #labels = Labels1dep,
           #nodeNames = Names1dep,
           lab=TRUE, 
           lab_size=2, 
           
           
           color= c( "darkmagenta", #"#DC3220", 
                    "white", "#009900"),
           #"forestgreen"), 
                   # "#005AB5"),
           
           show.diag = TRUE, tl.srt = 70)
           #title = "GAD-MDD Symptoms Network")



heatmapjandone <- heatmapjan + ggtitle("GAD-MDD Symptoms Network", subtitle = "Edge Weight Heat Map") +
  scale_x_discrete(labels=c("MS_Mood_Depressed" = "Dep",
                            "MS_AnhedoniaYN" = "Anh",
                            "MS_AppetiteYN" = "App",
                            "MS_SleepYN" = "Sle",
                            "MS_Psychomotor" = "Mot",
                            "MS_LowEnergy" = "Ene",
                            "MS_Guilt" = "Gui",
                            "MS_Concentration" = "Con",
                            "MS_SuicideIntent" = "Sui",
                            "GAD_Restless" = "Res",
                            "GAD_ExcessWorry" = "Wor",
                            "GAD_LackControl" = "LCo")) +
  
  scale_y_discrete(labels=c("MS_Mood_Depressed" = "Dep",
                            "MS_AnhedoniaYN" = "Anh",
                            "MS_AppetiteYN" = "App",
                            "MS_SleepYN" = "Sle",
                            "MS_Psychomotor" = "Mot",
                            "MS_LowEnergy" = "Ene",
                            "MS_Guilt" = "Gui",
                            "MS_Concentration" = "Con",
                            "MS_SuicideIntent" = "Sui",
                            "GAD_Restless" = "Res",
                            "GAD_ExcessWorry" = "Wor",
                            "GAD_LackControl" = "LCo"))
  

heatmapjandone 
```


```{r, eval=FALSE}
# remove ticks and labels
heatmpajan + ggtitle("pls") +
  theme(
  axis.text.x = element_blank(),
  axis.text.y = element_blank(),
  axis.ticks = element_blank())
  
 # theme(axis.text.y = c("LCo","Wor"))
#sig.level = 0.05,


#Labels1dep
#Names1dep


```

## Batch 2; dataset 09 idk 2023-11-28
###Pain day poster
```{r edits 11-28}
# visualize network --
save.plot <- qgraph(network_dep$graph, 
       layout = "spring",
       cut = 0,
       maximum = 0.4,
       
       palette = 'colorblind',
       
       groups = GroupLabels1dep,
       labels = Labels1dep,
       nodeNames = Names1dep.2,
       color = c('#d5ebf7', '#EAEAEA'), #d3d3d3'), #f0f0f0' #edit #d3d3d3 
       #original was 'lightgray'
       
       vsize= 4.5,
       label.cex= 1.2,
       legend.cex= .4,
       GLratio = 1.8) 

save.plot %>% plot()
       
      #posCol = default is set to darkgreen)


# vsize=4.5,label.cex=1.3,legend.cex=.38, GLratio = 1.8)


```


```{r edits 11-28, eval = F}

edge.color = matrix(as.vector(lapply(network_dep$graph$edgecolor,
                                           function(x) {gsub("darkgreen", "blue", x)})), nrow=4, ncol=4),
                       pie = pie1a_manual, pieBorder = 0.25, pieColor = "red") #







# other consideration
community
community_membership



##edge.color =fit_k2$pairwise$edgecolor) # incorporate sign as color
fit_k2
network_dep$
```


4) Predict values
pred_obj <- predict(fit_k3, autism_data$data)

head(pred_obj$predicted) # first six rows of predicted values
pred_obj$errors # Nodewise errors



apred_obj <- predict(afit_k3, data_n1$data)

head(apred_obj$predicted) # first six rows of predicted values
apred_obj$errors # Nodewise errors



```{r}
# Compute Predictability
#pie1a<- as.numeric(as.character(Pred1a$errors[1:6, 3]))#predictability estimates --> only the first three are continuous
#mean(pie1a)
 # pie1a_manual <- as.numeric(as.character(c("0.038","0.764", "0.331", "0","0","0"))) ## TO DO: figure out predictability for continuous variables

# Compute Predictability
Pred1a <- predict(bs_network1a_gam25_init, data_n1$data)
Pred1a$errors
pie1a<- as.numeric(as.character(Pred1a$errors[1:6, 3]))#predictability estimates
mean(pie1a)


pie1a_manual <- as.numeric(as.character(c(Pred1a$errors[1:3, 3], 0,0,0)))
##mean(pie1a_manual)


```







# ---


What are the most central nodes for Dep
- based on strength: restless, excess worry
```{r}
# == Centrality table and plot ==

plott <-   centralityPlot(edgesn2, include = c('Strength', 'ExpectedInfluence'))

## 
plott

# contains standardized centrality estimate
##centralityTable(edgesn2) %>% filter(measure == c("Strength")) %>% knitr::kable()


#are the central nodes SIGNIFICANTLY more central though? ==> centrality difference test

```

# ~ centrality batch 3 jan18
```{r}
jancentrality <- centralityPlot(edgesn2, include = c(#'Betweenness','Closeness',
'Strength',
'ExpectedInfluence'
)) 

jancentralitydone <- jancentrality + scale_y_discrete(labels=c("MS_Mood_Depressed" = "Dep",
                            "MS_AnhedoniaYN" = "Anh",
                            "MS_AppetiteYN" = "App",
                            "MS_SleepYN" = "Sle",
                            "MS_Psychomotor" = "Mot",
                            "MS_LowEnergy" = "Ene",
                            "MS_Guilt" = "Gui",
                            "MS_Concentration" = "Con",
                            "MS_SuicideIntent" = "Sui",
                            "GAD_Restless" = "Res",
                            "GAD_ExcessWorry" = "Wor",
                            "GAD_LackControl" = "LCo"))
jancentralitydone
```


## Stability of GAD-MDD Network (via bootnet)

***
THIS CODE CHUNK TAKES LIKE 20M TO RUN
***

### run bootstrap for network_gad
```{r, eval = F}
# -------------------------------------------------------------------------
# --------------- Bootstrap Network 2 ------------------------------------
# -------------------------------------------------------------------------

# fried: Set bootstrap number nB <- 500 , nCores =8
set.seed(111)
b1_dep <- bootnet(network_dep, boots = 1000, nCore = 4, 
                  
              statistics = c("strength", "expectedInfluence", "edge")) # ithink type is nonparametric

b2_dep <- bootnet(network_dep, boots = 1000, nCore = 4, type = "case",
              statistics = c("strength", "expectedInfluence", "edge"))
#case-dropping



save(b1_dep, file = "C:/Users/School/OneDrive - McGill University/DR MARTEL/Abstract for may/23-11-02_b1_dep.RData")

save(b2_dep, file = "C:/Users/School/OneDrive - McGill University/DR MARTEL/Abstract for may/23-11-02_b2_dep.RData")
```

#### load bootnet
```{r, eval = FALSE}

#b1_dep <- 
  #load(file = "23-11-02_b1_dep.RData")

load("C:/Users/School/OneDrive - McGill University/DR MARTEL/Abstract for may/23-11-02_b1_dep.RData")



#b2_dep<- 
  #load(file = "23-11-02_b2_dep.RData")

 b2_dep <-  load("C:/Users/School/OneDrive - McGill University/DR MARTEL/Abstract for may/23-11-02_b2_dep.RData")
  
  
  


```

## ~ stability of edges
```{r, error = T}

# == Edge weight stability graph ==
plot(b1_dep, labels = F, order = "sample")  ## can also set edge weights to F/T
    #bootstrap mean vs sample, EDGE WEIGHTS
      ##plot(b1_gad,order="sample",plot="area", prop0=TRUE)  #edge weight stability

b1dep_edge <- plot(b1_dep, labels = F, order = "sample")


# == strength stability graph == 
plot(b2_dep) 



# == centrality stability coefficient ==
corStability(b2_dep) 

## get confidence intervals.... 
#b1_gad %>%  summary() %>% filter(type == "strength") %>% dplyr::select(mean, CIlower, CIupper)
```


## ~ NEW: Get CIs for bootstrapped Edges
```{r, error = T}
# NEW ... bootstrapped confidence intervals
boot_dep1 <- b1_dep%>% summary()



# TEST - two commands give the same numbers
#values from the above plot TESTa
b1dep_edge$data %>% filter(id == "GAD_ExcessWorry--GAD_LackControl") 
  ## mean_non0 3.722859
  ## [3.152128	4.419488] slightly dif than the gad-only network, for mean and CI

## these should match w the gray areas of the above plot
boot_dep1 %>%  # TESTb
  filter(type == "edge", node1=="GAD_ExcessWorry", node2 =="GAD_LackControl") #%>% 
  #select(type, id, mean, CIlower, CIupper) # NEW - edge CIs

    ## 3.722859 mean	
    ## [3.136757,	4.425348]



##test c
## compare to heatmap edge values to the bootstrapped edge values
heat_dep$data %>% arrange(desc(value)) #3.78	 mean original sample

## good! consdieringe considering stability is good for edges  0.751
corStability(b2_dep)
# !! what to report?
```

## ~ NEWl PRINT edges table
```{r}
dep_bootstrap <- boot_dep1 %>% filter(type == "edge") %>% arrange(desc(mean))
dep_sample <- heat_dep$data %>% arrange(desc(value)) %>% dplyr::select(Var1,Var2, value) %>% rename(node1 = Var2, node2 = Var1, edgevalue = value)

dep_edgesCI <- merge(dep_sample, dep_bootstrap)


# important result
dep_edgesCI %>% dplyr::select(id, node1, node2, edgevalue, mean, sd, CIlower, CIupper) %>%  arrange(desc(edgevalue)) # NEW!!!! CI TABLE with sample and bootstrap values



```






```{r, error = T}
#differenceTest(b2_dep)
```
```{r, eval = F}
# strength CI :
boot_dep1 %>% 
  filter(type == "strength") %>%
  select(-c(mean, 10:17)) # NEW - strength CIs
##(not z scores though?)

boot_dep1 %>% 
  filter(type == "edge") %>% 
  select(type, id, mean, sd, CIlower, CIupper) # NEW - edge CIs
## the only thing with this is - verify it makes sense w the heat map values 


# stability of the model though.... if not that great might not be the same.... do I only report the bootstrapped edges of a stable model? col for bootstrap estimate additional alongside the network initial value, then CI?

```



**interpreting 
stability - ede weights and centrality index (Strength)

*central strength stability plot*
```{r, error = T}
## central Strength stability graph

plot(b2_dep, order="sample", plot="area", prop0=TRUE)    #strength stablity?


plot(b2_dep, "strength", order = "sample", labels = T )
  #plot(b1, "strength", order = "sample", labels = T )


plot(b2_dep, 'all')


```



#. 
#, 
# == PART 2 : other code learning resources ====



# === Network Estimation -- as per fried example ====
Chen S, Witten DM & Shojaie (2015). Selection and estimation for mixed graphical models. Biometrika, 102(1), 47. 
  ???? idk ehat this means  We can relax this assumption by fitting nonlinear edge potentials using semiparametric penalized regressions, as in Voorman et al. (2014).
```{r}
# -------------------------------------------------------------------------
# --------------- Loading packages & Data ---------------------------------
# -------------------------------------------------------------------------

library(mgm) 
library(qgraph)

# load("networks.RData") for all R files to reproduce analyses below; does not contain data ...
# ... which we are not allowed to make public for this project; see manuscript on how to get the NESDA data.

# In general, we'll estimate all networks with gamma=0 for the main paper, and with gamma=.25 for sensitivity analyses.
# ... We'll then compare both models to report differences.
```


### to do :
- figure out ModSel equiv for mgm -- is it just mgm?
- figure out predictability for dichotomous variables -- see the sex var in fried example
- centrality graphs apply to this example


whats the different between estimate network and mgm functions


# fit network1 with bootnet::estimateNetwork
```{r}
# -------------------------------------------------------------------------

#Data <- Data %>% select(-BPDTotal_mm)


data_n1 <- list("data" = NULL, 
                  "type" = NULL, 
                  "level" = NULL,
                  "names" = NULL,
                  "labels" = NULL,
                  "grouplabels"= NULL)

# Fill in
data_n1$data <- as.matrix(subset(Data, select = c(BPDTotal, GADTotal, MSMoodTotal, MS_AnhedoniaYN, GAD_ExcessWorry, GAD_LackControl))) #nodes of interest only, 6
data_n1$type <- c(rep("g", 3), rep("c", 3)) # c categorical; g continuous
data_n1$level <- c(rep(1, 3), rep(2, 3)) # 1 for Continuous variables by convention; >1 for categorical
data_n1$labels <- c("BPDTotal", "GADTotal", "MSMoodTotal", "MS_AnhedoniaYN", "GAD_ExcessWorry", "GAD_LackControl")    
data_n1$names <- c("BPDTot", "GADTot", "MoodTot", "Anhdnia", "ExcsWry", "LckCtrl")




n1 <- mgm(data = data_n1$data, #method is glm by default and only
          type = data_n1$type, #gaussian and categorical
          level = data_n1$level,   #number of categories for each variable
          #lambdaSel = tuning parameter for penalization; CV or EBIC... ebic more conserv, cv cannot be perf with categorical vars
          #alphaSel hypertuning for EBIC
          # k = interactions; 2 means all pairwise interactions, 3 is all pairwise and three way... d+1
          #threshold = below which edge-weights are put to 0
          binarySign = TRUE)



#mgms are non normalizeable for all paramter values????

```
!!!! *important* 
 See Chen, Witten & Shojaie (2015) for an overview of when pairwise MGMs are normalizable. To our best knowledge, for MGMs with interactions of order > 2 that include non-categorical variables, the conditions for normalizablity are unknown.



# - - - - - - - - - - -
# autism

```{r}
## We fit a pairwise and 3-order MGM to the mixed Autism dataset (?autism_data)
library(mgm)
autism_data %>% summary()
##data_n1 %>% summary()
```


```{r}

```

## fit a pairwise %>% to the dataset
```{r}
# 1) Fit Pairwise MGM
# Call mgm()
fit_k2 <- mgm(data = autism_data$data,
              type = autism_data$type,
              level = autism_data$lev,
              k = 2) # ad most pairwise interacitons
fit_k2





#mydata
afit_k2 <- mgm(data = data_n1$data,
              type = data_n1$type,
              level = data_n1$level,
              k = 2) # ad most pairwise interacitons
afit_k2

```


```{r}
# Weighted adjacency matrix
fit_k2$pairwise$wadj

afit_k2$pairwise$wadj
```

## visualize using qpgrah
```{r}
# Visualize using qgraph()
library(qgraph)
qgraph(fit_k2$pairwise$wadj,
       edge.color = fit_k2$pairwise$edgecolor,
       layout = "spring",
       labels =  autism_data$colnames)






qgraph(afit_k2$pairwise$wadj,
       edge.color = afit_k2$pairwise$edgecolor,
       layout = "spring",
       labels =  data_n1$labels)
```

## fit a pairwise and 3-order MGM to the dataset
```{r}
# 2) Fit MGM with pairwise & three-way interactions
fit_k3 <- mgm(data = autism_data$data,
              type = autism_data$type,
              level = autism_data$lev,
              k = 3) # include all interactions up to including order 3

afit_k3 <- mgm(data = data_n1$data,
              type = data_n1$type,
              level = data_n1$level,
              k = 3) # include all interactions up to including order 3




# List of estimated interactions
fit_k3$interactions$indicator

afit_k3$interactions$indicator
```

## plot factor graph
```{r}
# 3) Plot Factor Graph 
FactorGraph(object = fit_k3, 
            PairwiseAsEdge = FALSE, 
            labels = autism_data$colnames)

FactorGraph(object = afit_k3, 
            PairwiseAsEdge = FALSE, 
            labels = data_n1$names)
```

## predict values
```{r}
# 4) Predict values
pred_obj <- predict(fit_k3, autism_data$data)

head(pred_obj$predicted) # first six rows of predicted values
pred_obj$errors # Nodewise errors



apred_obj <- predict(afit_k3, data_n1$data)

head(apred_obj$predicted) # first six rows of predicted values
apred_obj$errors # Nodewise errors
```



idk
```{r eval = F}
## Here we illustrate why we need to overparameterize the design matrix to 
## recover higher order interactions including categorical variables

# 1) Define Graph (one 3-way interaction between 3 binary variables!!!)

# a) General Graph Info
type = c("c", "c", "c")
level = c(2, 2, 2)
# b) Define Interaction
factors <- list()
factors[[1]] <- NULL # no pairwise interactions
factors[[2]] <- matrix(c(1,2,3), ncol=3, byrow = T) # one 3-way interaction
interactions <- list()
interactions[[1]] <- NULL
interactions[[2]] <- vector("list", length = 1)
# threeway interaction no1
interactions[[2]][[1]] <- array(0, dim = c(level[1], level[2], level[3]))
theta <- .7
interactions[[2]][[1]][1, 1, 1] <- theta  #weight theta for conf (1,1,1), weight 0 for all others
# c) Define Thresholds
thresholds <- list()
thresholds[[1]] <- c(0, 0)
thresholds[[2]] <- c(0, 0)
thresholds[[3]] <- c(0, 0)

# 2) Sample from Graph
iter <- 1
set.seed(iter)
N <- 2000
d_iter <- mgmsampler(factors = factors,
                     interactions = interactions,
                     thresholds = thresholds,
                     type = type,
                     level = level,
                     N = N,
                     nIter = 50,
                     pbar = TRUE)


# 3.1) Estimate order 3 MGM using standard parameterization
d_est_stand <- mgm(data = d_iter$data,
                   type = type,
                   level = level,
                   k = 3,
                   lambdaSel = "CV",
                   ruleReg = "AND",
                   pbar = TRUE, 
                   overparameterize = FALSE, 
                   signInfo = FALSE)

# We look at the nodewise regression for node 1 (same for all)
coefs_stand <- d_est_stand$nodemodels[[1]]$model
coefs_stand 
# We see that nonzero-zero pattern of parameter vector does not allow us to infer whether 
# interactions are present or not


# 3.2) Estimate order 3 MGM using overparameterization
d_est_over <- mgm(data = d_iter$data,
                  type = type,
                  level = level,
                  k = 3,
                  lambdaSel = "CV",
                  ruleReg = "AND",
                  pbar = TRUE, 
                  overparameterize = TRUE, 
                  signInfo = FALSE)

# We look at the nodewise regression for node 1 (same for all)
coefs_over <- d_est_over$nodemodels[[1]]$model
coefs_over # recovers exactly the 3-way interaction
```


# - - - - - - - - - - - - 






# NETWORKS

# 1) autism ver -- uses mgm
```{r}
qgraph(afit_k2$pairwise$wadj,
       edge.color = afit_k2$pairwise$edgecolor,
       layout = "spring",
       labels =  data_n1$labels)

FactorGraph(object = afit_k3, 
            PairwiseAsEdge = FALSE, 
            labels = data_n1$names)


apred_obj <- predict(afit_k3, data_n1$data)

head(apred_obj$predicted) # first six rows of predicted values
apred_obj$errors # Nodewise errors
```


# 2) Fried version -- uses mgm

```{r}
# -------------------------------------------------------------------------
# --------------- Estimate Network 1a -------------------------------------
# -------------------------------------------------------------------------

# Get data
##data_n_1a <- readRDS(file = paste0(dataPrDir, "2023-09-29_data_n_1a.RDS"))

# ---------- Gamma = 0 model ----------

# Fit model
bs_network1a_gam0_init <- mgm(data = data_n1$data, 
                              type = data_n1$type, 
                              level = data_n1$level, 
                              lambdaSel = "EBIC", 
                                binarySign = TRUE, ##
                              lambdaGam = 0)

# Compute Predictability
Pred1a <- predict(bs_network1a_gam0_init, data_n1$data)
Pred1a$errors

Pred1a$errors[1:6, 3]
pie1a<- as.numeric(as.character(Pred1a$errors[1:6, 3]))#predictability estimates --> only the first three are continuous
mean(pie1a)



pie1a_manual <-  as.numeric(as.character(c(Pred1a$errors[1:3, 3], "0","0","0")))
  
  #Pred1a$errors[1:3, 3] %>% as.character() %>% as.numeric()
   ## TO DO: figure out predictability for continuous variables



# Plot Network
Names1a<-c("BPDTotal", "GADTotal", "MSMoodTotal", "Anhedonia", "Excess Worry", "Lack Control")
Labels1a<-c("BPD", "GAD", "Mood", "Anh", "Exc", "Lck")
GroupLabels1a <- list("Total Scores" = c(1:3), "Binary" = c(4:6))
```




### a) with gamma = 0 
```{r}
set.seed(111)
## simple ver
qgraph(input = bs_network1a_gam0_init$pairwise$wadj,  # now weighted adjacency matrix
       layout = "spring",
       nodeNames = data_n1$names, 
       edge.color = bs_network1a_gam0_init$pairwise$edgecolor) # incorporate sign as color



## actual ver -- except for the pie.... can see Rochester vid for color coding
# ----------- Gamma set to 0 -------------------------
N1amgm0 <- qgraph(bs_network1a_gam0_init$pairwise$wadj, 
                  layout = "spring", 
                  cut=0,
                  maximum = 0.4, 
                  #groups=GroupLabels1a, 
                  palette = "colorblind",
                  nodeNames=Names1a, 
                 labels = Labels1a, 
                  vsize=4.5,
                  label.cex=1.3, 
                 legend.cex=.38, 
                 GLratio = 1.8,
                  #edge.color = matrix(as.vector(lapply(bs_network1a_gam0_init$pairwise$edgecolor, function(x) {gsub("darkgreen", "blue", x)})), nrow=4, ncol=4),
                  pie = pie1a_manual, pieBorder = 0.25, pieColor = "red") # need to fix pie for binary --- also didnt do skew for binary
```

## b) with gamma = 0.25
```{r}
# ---------- Gamma = .25 model ----------

# Fit model
bs_network1a_gam25_init <- mgm(data = data_n1$data, 
                              type = data_n1$type, 
                              level = data_n1$level, 
                              lambdaSel = "EBIC", 
                                binarySign = T,
                              lambdaGam = 0.25)
                  # do i need to set k? i think default is 2



# Compute Predictability
#pie1a<- as.numeric(as.character(Pred1a$errors[1:6, 3]))#predictability estimates --> only the first three are continuous
#mean(pie1a)
 # pie1a_manual <- as.numeric(as.character(c("0.038","0.764", "0.331", "0","0","0"))) ## TO DO: figure out predictability for continuous variables

# Compute Predictability
Pred1a <- predict(bs_network1a_gam25_init, data_n1$data)
Pred1a$errors
pie1a<- as.numeric(as.character(Pred1a$errors[1:6, 3]))#predictability estimates
mean(pie1a)


pie1a_manual <- as.numeric(as.character(c(Pred1a$errors[1:3, 3], 0,0,0)))
##mean(pie1a_manual)



# Plot Network
Names1a<-c("BPDTotal", "GADTotal", "MSMoodTotal", "Anhedonia", "Excess Worry", "Lack Control")
Labels1a<-c("BPD", "GAD", "Mood", "Anh", "Exc", "Lck")
GroupLabels1a <- list("Total Scores" = c(1:3), "Binary" = c(4:6)) 


## actual ver -- except for the pie.... can see Rochester vid for color coding


N1amgm25 <- qgraph(bs_network1a_gam25_init$pairwise$wadj, layout = "spring", cut=0,
                 maximum = 0.4, 
                 #groups=GroupLabels1a, 
                 palette = "colorblind",
                 nodeNames=Names1a, labels = Labels1a, vsize=4.5,
                 label.cex=1.3, legend.cex=.38, GLratio = 1.8,
                 #edge.color = matrix(as.vector(lapply(bs_network1a_gam25_init$pairwise$edgecolor, function(x) {gsub("darkgreen", "blue", x)})), nrow=4, ncol=4),
                 pie = pie1a_manual, pieBorder = 0.25, pieColor = "red")

```


### N1 comparison
* bpd total doesnt have a strong edge with any
```{r}
qgraph(afit_k2$pairwise$wadj,
       edge.color = afit_k2$pairwise$edgecolor,
       layout = "spring",
       labels =  data_n1$labels) #looks the same

N1amgm0 %>% plot()
N1amgm25 %>% plot()

N1amgm0
N1amgm25

 
 
# ---------- 1a comparison ----------
# FROM FRIED: For model 1a there is no difference for biopsycho edges when gamma = 0 or when gamma = 0.25...  In fact, both models are *exactly* identical

cor(as.vector(bs_network1a_gam0_init$pairwise$wadj), as.vector(bs_network1a_gam25_init$pairwise$wadj))
```

## Edges, Centrality plot and table
```{r}
# Edges - aka partial correlation matrix
getWmat(N1amgm0) ## gamma 0

  ##getWmat(N1amgm25) ## gamma 0.25 ... theyre really similar (the correlation above is 1)



# Centrality indices; plot and table
## gamma 0
centralityPlot(N1amgm0, include = c("Strength", "ExpectedInfluence"))


centrality_auto(N1amgm0)
##centrality_auto(n1a) same

  centralityTable(N1amgm0)


```








### save plot
```{r, eval=FALSE}
pdf("2023-10-04_MyNetwork_gm0.pdf") #name
myplot <- plot(N1amgm0, layout = "spring", vsize = 6,
               border.color = "black", nodeNames = Names1a, color = "lightblue", legend = F)
dev.off()
```


see :Plot model 1a as pdf for main figure and supplementary


# 3a) normalized 
## plot and edges
```{r}
norm_n1<- list("data" = NULL, 
                  "type" = NULL, 
                  "level" = NULL,
                  "names" = NULL,
                  "labels" = NULL,
                  "grouplabels"= NULL)

# Fill in
norm_n1$data <- as.matrix(subset(normalizedcont, select = c(BPDTotal, GADTotal, MSMoodTotal, MS_AnhedoniaYN, GAD_ExcessWorry, GAD_LackControl))) #nodes of interest only, 6
norm_n1$type <- c(rep("g", 3), rep("c", 3)) #g continuous,  c categorical
norm_n1$level <- c(rep(1, 3), rep(2, 3)) # 1 for Continuous variables by convention; >1 for categorical
norm_n1$labels <- c("BPDTotal", "GADTotal", "MSMoodTotal", "MS_AnhedoniaYN", "GAD_ExcessWorry", "GAD_LackControl")    
norm_n1$names <- c("BPDTot", "GADTot", "MoodTot", "Anhdnia", "ExcsWry", "LckCtrl")

nn1a <-  estimateNetwork(norm_n1$data, default = "mgm")

##norm.n1a %>% plot()


edgesnorm <- getWmat(nn1a)

#edgesn1a %>% qgraph()

qgraph(edgesnorm,
                  layout = "spring", 
                  cut=0,
                  maximum = 0.4, 
                  #groups=GroupLabels1a, 
                  palette = "colorblind",
                  nodeNames=Names1a, 
                 labels = Labels1a, 
                  vsize=4.5,
                  label.cex=1.3, 
                 legend.cex=.38, 
                 GLratio = 1.8)


edgesnorm 
#edgesn1a



```
## centrality
```{r}
#nn1a %>% centralityPlot(include = c("Strength" , "ExpectedInfluence"
                                   ))
  #nn1a %>% centralityTable()
#nn1a %>% centrality_auto()

#nn1a %>% getWmat() #edges
  

centralityPlot(edgesnorm)
centralityTable(edgesnorm)
```



## bootstrap
```{r, eval = F}
#stability of normalized model

# fried: Set bootstrap number nB <- 500 , nCores =8


set.seed(111)
bn1 <- bootnet(nn1a, boots = 1000, nCore = 4, 
              statistics = c("strength", "expectedInfluence", "edge")) # i think type is nonparametric

bn2 <- bootnet(nn1a, boots = 1000, nCore = 4, type = "case",
              statistics = c("strength", "expectedInfluence", "edge"))
#case-dropping



save(bn1, file = "23-10-13_bn1_continuous normalized.RData")
save(bn2, file = "23-10-13_bn2_continous normalized.RData")

```
### stability 
difference test didnt worjk
```{r}

## stability coefficients == 0.673
corStability(bn2)

## Edges stability graph
plot(bn1, labels = T, order = "sample")


## central Strength stability graph
plot(bn2, "strength", order = "sample", labels = T )
  #plot(b1, "strength", order = "sample", labels = T )


```



# 3b) estimateNetwork 
```{r}
n1a <- estimateNetwork(data = data_n1$data,   
                       type = data_n1$type, 
                       level = data_n1$level, 
                       default="mgm",
                       criterion = "EBIC", 
                       tuning = 0) # do i leave this like this
n1a

### check if bootnet results match mgm estimation results, using absolute values ...
### ... for estimateNetwork because this is the way pairwise$wadj is encoded in mgm

library(OpenMx)
##cor(vech(bs_network1a_gam0_init$pairwise$wadj), vech(abs(n1a$graph)))
```
## plot network, get edges
```{r}
#n1a %>% plot()
edgesn1a <- getWmat(n1a)

#edgesn1a %>% qgraph()

qgraph(edgesn1a,
                  layout = "spring", 
                  cut=0,
                  maximum = 0.4, 
                  #groups=GroupLabels1a, 
                  palette = "colorblind",
                  nodeNames=Names1a, 
                 #labels = Labels1a, 
                  vsize=4.5,
                  label.cex=1.3, 
                 legend.cex=.38, 
                 GLratio = 1.8)
                  #edge.color = matrix(as.vector(lapply(bs_network1a_gam0_init$pairwise$edgecolor, function(x) {gsub("darkgreen", "blue", x)})), nrow=4, ncol=4),
                 # pie = pie1a_manual, pieBorder = 0.25, pieColor = "red") # n


```

### edge weights, centrality table and plot
```{r}
edgesn1a <- n1a %>% getWmat()
edgesn1a

centralityPlot(edgesn1a)
centralityTable(edgesn1a) # contains standardized centrality estimate

#are the central nodes SIGNIFICANTLY more central though? ==> centrality difference test
```


##  edge heatmap
```{r}
library(ggcorrplot)
# -------------------------------------------------------------------------
# --------------- Plot network edges in heatmaps --------------------------
# -------------------------------------------------------------------------

colnames(n1a$graph)<- rownames(n1a$graph) #<- Labels1a

#pdf(paste0(figDir2, "heatmap_1a.pdf"))
ggcorrplot(n1a$graph, method="circle", legend = "Edge Weights", 
           lab=TRUE, lab_size=2, type = "lower", color= c("red", "white", "blue"),
           show.diag = TRUE, tl.srt = 70, title = "Network 1a")
#dev.off()


```



## STABILITY VIA bootstrap


***
THIS CODE CHUNK TAKES LIKE 20M TO RUN
***

### run bootstrap for n1a
```{r, eval = T}

# -------------------------------------------------------------------------
# --------------- Bootstrap Network 1a ------------------------------------
# -------------------------------------------------------------------------

# fried: Set bootstrap number nB <- 500 , nCores =8
set.seed(111)
b1 <- bootnet(n1a, boots = 1000, nCore = 4, 
              statistics = c("strength", "expectedInfluence", "edge")) # ithink type is nonparametric

b2 <- bootnet(n1a, boots = 1000, nCore = 4, type = "case",
              statistics = c("strength", "expectedInfluence", "edge"))
#case-dropping



save(b1, file = "23-10-13_b1.RData")
save(b2, file = "23-10-13_b2.RData")

```

```{r, eval = FALSE}

b1. <- load(file = "23-10-13_b1.RData")
b2. <- load(file = "23-10-13_b2.RData")


```


default 	<-- do i set this argument ? # to learn
A string indicating the method to use. See documentation at estimateNetwork.


Expected significance level given number of bootstrap samples is approximately: 0.05

## !? Bootstrap difference test
```{r}
differenceTest(b2)
```


## interpreting 
stability - ede weights and centrality index (Strength)

### stability

### *stability coefficients*
```{r}
corStability(b2) #centrality stability coefficient --> 0.75 for edge, EI and strength

#STABILITY
## get confidence intervals.... b1 %>% summary() %>% filter(type == "strength") %>% select(mean, CIlower, CIupper)
```

### *edges stability plot*
```{r}
## Edges stability graph
plot(b1, labels = F, order = "sample")




#pdf(paste0(figDir, "b1.pdf"))
plot(b1, order="sample", plot="area", prop0=TRUE)  #edge weight stability
    #dev.off()
```



### *central strength stability plot*
```{r}
## central Strength stability graph

plot(b2, order="sample", plot="area", prop0=TRUE)    #strength stablity?


plot(b2, "strength", order = "sample", labels = T )
  #plot(b1, "strength", order = "sample", labels = T )


```
*results*: 0.75 for edge, expectedInfluence and strength


values for and centrality indices (strength and expected influence)


### Difference tests
is one node significally more central than another

black squares are significant

### *strength difference plot*
```{r}

##strength differences
plot(b1, "strength", plot = "difference", order = "sample", labels = T )
```


### *edge weight difference plot*
```{r}
## edge weight differences
##plot(b1, "edge", plot = "difference", onlyNonZero = T, order = "sample", labels = T )
plot(b1, "edge", plot = "difference", onlyNonZero = F, order = "sample", labels = T )  # to justify BPD omission for ex
```

### *Expected influence difference plot*
```{r}
## Expected Influence differences
plot(b1, "expectedInfluence", plot = "difference", order = "sample", labels = T )


```












# -----
``` {r, eval = F}
# -------------------------------------------------------------------------
# --------------- Estimate Network 2a -------------------------------------
# -------------------------------------------------------------------------

##data_n_2a <- readRDS(file = paste0(dataPrDir, "data_n_2a.RDS"))

# ---------- Gamma = 0 model ----------

data_n_2a <- data_n_1a


# Fit initial model
bs_network2a_gam0_init <- mgm(data = data_n_2a$data, 
                              type = data_n_2a$type, 
                              level = data_n_2a$level, 
                              lambdaSel = "EBIC", 
                              binarySign = TRUE, 
                              lambdaGam = 0)

# Compute Predictability
Pred2a <- predict(bs_network2a_gam0_init, data_n_2a$data)
Pred2a$errors
```


``` {r, eval = F}
pie2aa<- as.numeric(as.character(Pred2a$errors[1:10, 3]))
pie2aaa<- as.numeric(as.character(Pred2a$errors[11, 5]))
pie2aaaa<- as.numeric(as.character(Pred2a$errors[12, 3]))
pie2a<-c(pie2aa, pie2aaa, pie2aaaa)#predictability estimates as one piece
mean(pie2a)
#error.nCC for sex is negative; recode error.cc for sex <---
pie2aab<- as.numeric(as.character(Pred2a$errors[11, 4]))
pie2a<-c(pie2aa, pie2aab, pie2aaaa) # combine
```



```{r}
mynetwork <- bs_network1a_gam0_init
```







# .
#. 
#.

# ignore 
```{r}
##install.packages("bootnet")
library(bootnet)
library(ggplot2)
```


```{r, eval = F}
set.seed(111)
m1 <- bootnet(data = Data, default = "mgm")

```


# NETWORK attempt 2 to run network; per levinson vid
```{r, eval  = F}
#assign names to nodes
mynodes <- Data %>% colnames() #regularized the continuous vars
Data %>% str()


Data$type <- c(rep("g", 3), rep("c", 3)) # c categorical; g continuous

data_n_1a$level <- c(rep(1, 3), rep(2, 3)) # 1 for Continuous variables by convention; >1 for categorical
data_n_1a$labels <- c("BPDTotal", "GADTotal", "MSMoodTotal", "MS_AnhedoniaYN", "GAD_ExcessWorry", "GAD_LackControl")    

data_n_1a <- as.data.frame(data_n_1a$data)

#estimate network using default method=mgm, spearman cor (use if dense)
set.seed(111)
mynetwork0 <- estimateNetwork(data_n_1a, default = 'mgm')

```


## bootstrap
# how to save bootstrap
```{r, eval = F}
set.seed(111)
b1 <- bootnet(mynetwork, boots = 1000, nCore = 4, 
              statistics = c("strength", "expectedInfluence", "edge")) # ithink type is nonparametric

b2 <- bootnet(mynetwork, boots = 1000, nCore = 4, type = "case",
              statistics = c("strength", "expectedInfluence", "edge"))
#case-dropping

```

default 	<-- do i set this argument ? # to learn
A string indicating the method to use. See documentation at estimateNetwork.


